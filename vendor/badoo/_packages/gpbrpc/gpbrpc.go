package gpbrpc

import (
	"errors"
	"io"
	"net"
	"reflect"
	"strings"

	"github.com/gogo/protobuf/proto"
)

type ConnStatus int32

const (
	ConnOK         ConnStatus = 0 /* It's okay to use this connection */
	ConnEOF        ConnStatus = 1 /* EOF was detected up on read of the very first byte of a packet */
	ConnIOError    ConnStatus = 2 /* IO error */
	ConnParseError ConnStatus = 3 /* Received unacceptable data from a peer */
	// this one is unused for now
	// ConnBufferFull ConnStatus = 4 /* Buffer for io full */
)

// Knows about actual protocol structure, messages, their dispatch and specific protobuf structures implementing messages
// Real implemtations are generated by protoc-gen-gpbrpc-go
// in *.gpbrpc.go structure implementing this interface is called Gpbrpc for clarity :)
//  (clarity in that it resides in a different package, so naming is important)
type Protocol interface {
	Dispatch(request RequestT, handler interface{}) ResultT
	ErrorGeneric(args ...interface{}) ResultT
	GetPackageName() string

	// request
	GetRequestMsgid(msg proto.Message) uint32 // panics if unknown message (validate messages before passing, have to do it sometime anyway)
	GetRequestMsg(msgid uint32) proto.Message // returns nil on unknown msgid
	GetRequestNameToIdMap() map[string]uint32
	GetRequestIdToNameMap() map[uint32]string

	// response
	GetResponseMsg(msgid uint32) proto.Message // panics if unknown message (validate messages before passing, have to do it sometime anyway)
	GetResponseMsgid(msg proto.Message) uint32 // returns nil on unknown msgid
	GetResponseNameToIdMap() map[string]uint32
	GetResponseIdToNameMap() map[uint32]string
}

// ---------------------------------------------------------------------------------------------------------------
// Helpers

func MapRequestNameToId(p Protocol, name string) uint32 {
	return p.GetRequestNameToIdMap()[name]
}

func MapRequestIdToName(p Protocol, msgid uint32) string {
	return p.GetRequestIdToNameMap()[msgid]
}

func MapResponseNameToId(p Protocol, name string) uint32 {
	return p.GetResponseNameToIdMap()[name]
}

func MapResponseIdToName(p Protocol, msgid uint32) string {
	return p.GetResponseIdToNameMap()[msgid]
}

func MakeRequestIdToPinbaNameMap(p Protocol) map[uint32]string {
	result := make(map[uint32]string)

	for id, name := range p.GetRequestIdToNameMap() {
		result[id] = p.GetPackageName() + "." + name
	}

	return result
}

// get message name, without any regard for Protocol it might belong to
//  it's heavywheight on GC, so don't use if possible to avoid, use helpers defined above!
func Msgname(pb proto.Message) string {
	names := strings.Split(reflect.TypeOf(pb).String(), ".")
	return uncamelize(names[len(names)-1])
}

// helper for Msgname()
func uncamelize(s string) string {
	t := make([]byte, 0, 32)
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if ch >= 'A' && ch <= 'Z' {
			if len(t) > 0 {
				t = append(t, '_')
			}
		}
		t = append(t, ch)
	}
	return strings.ToUpper(string(t))
}

// ---------------------------------------------------------------------------------------------------------------
// low level io helpers, need a separate package, do they ?

func readAll(r io.Reader, buf []byte) (int, error) {
	buf_len := len(buf)
	read := 0

	for buf_len-read > 0 {
		read_oneshot, err := r.Read(buf)
		read += read_oneshot
		if err != nil {
			return read, err
		}
		buf = buf[read_oneshot:]
	}
	return read, nil
}

func writeAll(w io.Writer, buf []byte) (int, error) {
	buf_len := len(buf)
	written := 0

	for buf_len-written > 0 {
		written_oneshot, err := w.Write(buf)
		written += written_oneshot
		if err != nil {
			return written, err
		}
		buf = buf[written_oneshot:]
	}

	return written, nil
}

// FIXME: this does NOT work with multiple message in buffer (will handle just the first one)
//         and it's not trivially fixable, need to go up to codec and buffer data there
func readLine(conn net.Conn, buf []byte) (read int, err error) {
	buf_len := len(buf)
	read = 0
	for buf_len-read > 0 {
		var read_oneshot int
		read_oneshot, err = conn.Read(buf[read:])
		read += read_oneshot
		if err != nil {
			break
		}
		if buf[read-1] == '\n' {
			break
		}
	}

	if buf_len == read && buf[read-1] != '\n' {
		err = errors.New("read error: message too long")
	}

	return
}
